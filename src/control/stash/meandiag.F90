! *****************************COPYRIGHT*******************************
! (C) Crown copyright Met Office. All rights reserved.
! For further details please refer to the file COPYRIGHT.txt
! which you should have received as part of this distribution.
! *****************************COPYRIGHT*******************************
!
!    Routine: MEANDIAG -------------------------------------------------
!
!    Purpose: Outputs mean diagnostic PPfiles from within the means
!             program.  Fields are generated by the normal operation of
!             the climate meaning system (ie. all fields in D1 except
!             integer and logical data are averaged).
!             Fields which were already processed by STASH, stored in D1
!             and then meaned further by the meaning system are only
!             extracted to the mean PPfile if the STASH usage profile of
!             the original diagnostic processing record so indicates.
!             This is determined by a loop over all STASH records with a
!             check on the STASH tag field, with a further loop over the
!             number of output levels associated with the STASH record.
!
!    Programming standard: UM Doc Paper 3, version 2 (7/9/90)
!
!    Logical components covered: C5
!
!    Project task: C5
!
!    External documentation:
!      UM Doc Paper C5 - Calculation of means
!
!    -------------------------------------------------------------------
!    Interface and arguments: ------------------------------------------
!
!Code Owner: Please refer to the UM file CodeOwners.txt
!This file belongs in section: STASH

SUBROUTINE meandiag (                                  &
    i_ao,meanlev,pp_len_mean,step_dumps,mean_period,   &
    max_size,                                          &
    icode,cmessage)

USE model_file, ONLY:     &
    Get_File_Address,      &
    Mf_lookup_address,     &
    AttachLookups,         &
    Model_file_close
USE io, ONLY: setpos, buffout
USE io_constants, ONLY: ioNoDelete
USE parkind1, ONLY: jprb, jpim
USE yomhook, ONLY: lhook, dr_hook
USE atm_fields_bounds_mod
USE filenamelength_mod, ONLY: filenamelength
USE io_configuration_mod, ONLY: io_field_padding, l_postp
USE UM_ParVars
USE UM_ParCore,    ONLY: nproc
USE decomp_params, ONLY: decomp_standard_atmos
USE Control_Max_Sizes
USE Decomp_DB
USE umPrintMgr, ONLY:      &
    umPrint,                &
    umMessage,              &
    printstatus,            &
    prstatus_diag
USE lookup_addresses

USE cppxref_mod, ONLY:      &
    ppx_grid_type,          &
    ppx_packing_acc
USE nlstgen_mod, ONLY: steps_per_periodim, secs_per_periodim,   &
    dumpfreqim, ppselectim, meanfreqim, ft_meanim
USE dump_headers_mod, ONLY: a_fixhd, a_lookup
USE submodel_mod, ONLY: submodel_for_sm, atmos_im
USE d1_array_mod, ONLY: d1_imodl, d1_section, d1_item, d1_grid_type, d1, &
                        d1_addr
USE stash_array_mod, ONLY:                                                     &
    stash_pseudo_levels, totitems, stash_maxlen, stlist, stash_levels
USE ppxlook_mod, ONLY: exppxi

USE file_manager, ONLY: &
    um_file_type, get_file_by_id, assign_file_unit, release_file_unit

USE nlstcall_mod, ONLY: lclimrealyr, lcal360

USE nlsizes_namelist_mod, ONLY:                                          &
    a_len1_coldepc, a_len1_flddepc, a_len1_levdepc, a_len1_rowdepc,      &
    a_len2_coldepc, a_len2_flddepc, a_len2_levdepc, a_len2_lookup,       &
    a_len2_rowdepc, a_len_cfi1, a_len_cfi2, a_len_cfi3, a_len_extcnst,   &
    a_len_inthd, a_len_realhd, intf_len2_coldepc, intf_len2_levdepc,     &
    intf_len2_rowdepc, intf_lookupsa, land_field, len1_lookup,           &
    len_dumphist, len_fixhd, len_tot,                                    &
    max_intf_model_levels, max_lbcrow_length, max_lbcrows, model_levels, &
    mpp_len1_lookup, n_cca_lev, n_intf_a, n_obj_d1_max, pp_len_inthd,    &
    pp_len_realhd, sm_levels, st_levels, tpps_ozone_levels, tr_lbc_ukca, &
    tr_lbc_vars, tr_ukca, tr_vars

USE missing_data_mod, ONLY: rmdi

USE model_time_mod, ONLY:                                               &
    basis_time_days, basis_time_secs, i_day, i_hour, i_minute, i_month, &
    i_second, i_year
USE stparam_mod, ONLY: st_macrotag, st_input_bottom, st_special_code,   &
    st_gridpoint_code, vert_mean_top, vert_mean_base, st_series_ptr,    &
    st_output_bottom, st_output_top, st_pseudo_out, st_model_code,      &
    st_sect_no_code, st_item_code, st_lookup_ptr, st_output_addr,       &
    st_d1pos 

USE errormessagelength_mod, ONLY: errormessagelength

USE Packing_Codes_Mod, ONLY: PC_WGDOS_Packing, PC_RunLength_Packing,           &
    PC_No_Packing, PC_Cray_Format

IMPLICIT NONE


INTEGER ::                       &
    i_ao,                     &! IN  Atmosphere/Ocean indicator
    meanlev,                  &! IN  Mean level indicator
    pp_len_mean,              &! IN  Number of fields in output PPfile
    step_dumps,               &! IN  Timestep in multiples of restart
                               !     dump frequency.
    mean_period,              &! IN  meaning frequency.
    max_size,                 &! IN  maximum dump field size
    icode                      ! OUT return code; successful=0, error> 0
!
CHARACTER(LEN=errormessagelength) ::                &
    cmessage                   ! OUT Error message if ICODE > 0
!

! Dynamic allocated workspace
INTEGER, POINTER :: pplook(:,:)
REAL :: buf(max_size)  ! I/O buffer space

INTEGER :: ipplook(len1_lookup)          ! Copy of D1 field header

!     Local variables and arrays

REAL :: a_io                      ! IO error return code on BUFFER IO
INTEGER ::                    &
    word_address,             &! IO word address on BUFFER IO
    len_io,                   &! IO transfer length on BUFFER IO
    indexm,                   &! Mean level index
    field,                    &! Index over field number in LOOKUP
    field_address,            &! Address of field in D1
    field_length,             &! Length of single field
    buffer_length,            &! Length of buffer for field
    IS,im,                    &! STASH section,item codes for field
    ie,                       &! STLIST index over entries
    modl,                     &! Int. model no. read from STASH record
    tag,                      &! STLIST tag used to identify field
    nrows,                    &! No of rows in field
    ncols,                    &! No of columns in field
    no,n_levs,                &! Bottom level and number of levels
    level,                    &! Index over levels
    comp_accrcy,              &! Packing accracy
    lbtim_ia,                 &! Sampling period in hours for LBTIM
    lbtim_ib,                 &! Type of time field for LBTIM
    iwa,                      &! Word address used in SETPOS
    icurrll,                  &! Current position in PP LOOKUP table
    len_buf_words,            &! NUM_WORDS rounded to 512
    num_words,                &! Number of words reqd to hold the data
    i,                        &! Loop index
    nf,                       &! No of field
    start_day,                &! Start time for mean period (days)
    start_second,             &! Start time for mean period (seconds)
    period_days,              &! Start time for mean period (days)
    period_secs,              &! Start time for mean period (seconds)
    start_time(7),            &! Start time for mean period(date/time)
    im_ident,                 &! Internal Model Identifier
    im_index,                 &! Internal Model Index for stash
    packing_type,             &! 0=unpacked, 1=WGDOS
    d1pos,                    &! Position of info in D1_ADDR array
    orig_decomp,              &! Used to check for change in
    new_decomp                 ! decomposition
INTEGER :: len_extra ! IN size of expected extra data
INTEGER :: srow_out  ! Dummy - 1st southern row to output
INTEGER :: wcol_out  ! Dummy - 1st western column to output
LOGICAL ::                       &
    packing,                  &! Switch to enable optional packing
    lpackfield                 ! Per-field packing indicator

INTEGER ::                    &
     gr,                      &! Gridtype code
     global_pphoriz_out,      &! Size of global field
     info,                    &! Unused arg in GCOM calls
     local_len,               &! Length of field:
                               ! from GENERAL_GATHER_FIELD
     subm                      ! Submodel number for internal model id

REAL :: a                         ! To hold return code
                               ! from GENERAL_GATHER_FIELD


INTEGER :: grid_type ! grid type - for extra data processing
INTEGER :: fld_type  ! field type - for extra data processing
INTEGER :: get_fld_type ! Function
INTEGER :: ierr  ! GCOM returns
INTEGER :: ippval
REAL :: rppval
INTEGER, PARAMETER :: current_io_pe = 0

CHARACTER(LEN=filenamelength) :: archfile
INTEGER :: arch_unit

TYPE(um_file_type), POINTER :: um_file

INTEGER(KIND=jpim), PARAMETER :: zhook_in  = 0
INTEGER(KIND=jpim), PARAMETER :: zhook_out = 1
REAL(KIND=jprb)               :: zhook_handle

CHARACTER(LEN=*), PARAMETER :: RoutineName='MEANDIAG'

IF (lhook) CALL dr_hook(RoutineName,zhook_in,zhook_handle)
im_ident = i_ao
im_index = 1

! ----------------------------------------------------------------------
!  1. Initialise output ppfile for mean data at level MEANLEV.
!     OPEN the file ready to receive mean PPfields from STASH.
!
! DEPENDS ON: ppctl_init_climate_means
CALL ppctl_init_climate_means (          &
     i_ao,meanlev,icode,cmessage)
IF (icode >  0) GO TO 9999

! ----------------------------------------------------------------------
!  2. Extract mean fields from mean dump fields in D1, and append to
!     mean PPfile.  The fields dealt with in this section are the
!     prognostic fields as meaned by the climate meaning system, plus
!     fields derived from them (in the case of the atmosphere).
!     The STASH section number depends on the mean level and whether
!     atmosphere or ocean.  Different sets of fields can be requested
!     from different mean periods.
!
IF (i_ao == 1) THEN
  ! DEPENDS ON: st_mean
  CALL st_mean (                 &
                20+meanlev,stash_maxlen(20+meanlev,im_index),     &
                icode,cmessage)
END IF
IF (icode >  0) GO TO 9999
! ----------------------------------------------------------------------
!  3. Loop over STASHlist entries and extract tagged fields which are
!  already processed into D1 by STASH to the mean PP file
!
!  3.1 Get the address of lookups for the PP file
!
NULLIFY(um_file) 
um_file => get_file_by_id("aomean", handler="portio")
      
word_address = get_file_address(um_file % UNIT, mf_lookup_address)
!
!  3.2 Buffer in PPfile lookup header to PPLOOK work array
!
IF (mype == current_io_pe) THEN
  PPLook=>AttachLookups(um_file % UNIT)
ELSE
  ALLOCATE(pplook(len1_lookup,pp_len_mean))
END IF

! broadcast the lookup table to other PEs
CALL gc_ibcast(74,len1_lookup*pp_len_mean,current_io_pe,nproc,   &
    ierr,pplook)

!
!  3.3 Initialise output address and LOOKUP entry number in the PPfile
!
!
icurrll= um_file % pp_meta % last_written_field
IF (icurrll == 0) THEN  ! this is the first field
  iwa=word_address+len1_lookup*pp_len_mean
  ! round address up to io_field_padding-words
  iwa=((iwa+io_field_padding-1)/io_field_padding)*io_field_padding
ELSE                    ! append to the previous field
  iwa=PPLook(lbegin,icurrll)+PPLook(lbnrec,icurrll)
END IF

!
! Set packing switch : profile 0 means no packing
!
IF (um_file % meta % packing_code == 0) THEN
  packing=.FALSE.
ELSE
  packing=.TRUE.
END IF
!
!  3.4 Start loop over STASHlist entries.
!
!  3.41 Check if job exceeds the UM field limit
nf=0
DO ie=1,totitems
  tag=stlist(st_macrotag, ie)/1000
  IF (MOD(tag/(2**(meanlev-1)),2)  == 1) THEN
    IF ((stlist(st_input_bottom,ie) == st_special_code) .OR.       &
         (stlist(st_gridpoint_code,ie) <  vert_mean_top .AND.     &
          stlist(st_gridpoint_code,ie) >  vert_mean_base) .OR.     &
         (stlist(st_series_ptr,ie) >  0)) THEN
      n_levs=1
    ELSE
      no=stlist(st_output_bottom,ie)
      IF (no <  0) THEN
        n_levs=stash_levels(1,-no)
      ELSE
        n_levs=stlist(st_output_top,ie)-                          &
               stlist(st_output_bottom,ie)+1
      END IF
    END IF
    IF (stlist(st_pseudo_out,ie) >  0) THEN
      no=stlist(st_pseudo_out,ie)
      n_levs=n_levs*stash_pseudo_levels(1,no)
    END IF
    nf=nf+n_levs
  END IF
END DO
IF (nf >  pp_len_mean) THEN
  WRITE(umMessage,*)'ERROR: UM limit of ',pp_len_mean,                    &
            ' fields exceed'
  CALL umPrint(umMessage,src='meandiag')
  WRITE(umMessage,'(A)')             &
      ' STASH Requests Macros; STASHTstmskValidate in GUI'
  CALL umPrint(umMessage,src='meandiag')
  WRITE(umMessage,'(A)')'See STASH Requests panel'
  CALL umPrint(umMessage,src='meandiag')
  icode=4
  cmessage=' MEANDIAG: Exceed fields limit'
  GO TO 9999
END IF

!

IF (printstatus >= prstatus_diag) THEN
  WRITE(umMessage,*)'MEANDIAG: Processing ...'
  CALL umPrint(umMessage,src='meandiag')
END IF

DO ie =1,totitems
  modl=stlist(st_model_code  ,ie)
  IS  =stlist(st_sect_no_code,ie)
  im  =stlist(st_item_code   ,ie)

  tag =stlist(st_macrotag    ,ie)/1000
  IF ( (MOD(tag/(2**(meanlev-1)),2)  == 1) .AND.                  &
       (i_ao == modl) ) THEN

    IF (printstatus >= prstatus_diag) THEN
      WRITE(umMessage,'(1X,A,I4,I4)')'MEANDIAG: Section, Item was set to ',&
      IS,im
      CALL umPrint(umMessage,src='meandiag')
    END IF


    ! The Tag matches this mean period and the item is in this dump  .
    !
    ! Determine the number of output levels and starting LOOKUP header
    ! (Number of levels now includes possible pseudo_levels)
    ! NB: Note that vertical means (single output level) are a special case
    !     as are timeseries (also single output level)
    !
    IF (stlist(st_input_bottom,ie) == st_special_code) THEN
      n_levs=1                       ! Output is a special level
    ELSE IF (stlist(st_gridpoint_code,ie) <  vert_mean_top .AND.   &
            stlist(st_gridpoint_code,ie) >  vert_mean_base) THEN
      n_levs=1                       ! Output is a vertical mean
    ELSE IF (stlist(st_series_ptr,ie) >  0) THEN
      n_levs=1                       ! Output is a timeseries
    ELSE
      no=stlist(st_output_bottom,ie)
      IF (no <  0) THEN              ! Output is level list
        n_levs=stash_levels(1,-no)
      ELSE                           ! Output is level range
        n_levs=stlist(st_output_top,ie)-                          &
               stlist(st_output_bottom,ie)+1
      END IF
    END IF
    IF (stlist(st_pseudo_out,ie) >  0) THEN
      no=stlist(st_pseudo_out,ie)
      n_levs=n_levs*stash_pseudo_levels(1,no)
    END IF
    field=stlist(st_lookup_ptr,ie)
    ! Address of distributed field in D1
    field_address=stlist(st_output_addr,ie)
    !
    ! Loop over the number of output levels
    DO level=1,n_levs
      ! Copy LOOKUP header for field from A_LOOKUP to work header
      IF (i_ao == 1) THEN
        DO i=1,len1_lookup
          ipplook(i)=a_lookup(i,field+level-1)
        END DO
      END IF
      ! Field and buffer sizes, and field address in D1
      field_length =ipplook(lblrec)
      IF (field_length  >   max_size) THEN
        WRITE(umMessage,*) 'Error in MEANDIAG : MAX_SIZE too small.'
        CALL umPrint(umMessage,src='meandiag')
        WRITE(umMessage,*) 'MAX_SIZE= ',max_size
        CALL umPrint(umMessage,src='meandiag')
        WRITE(umMessage,*) 'FIELD_LENGTH= ',field_length
        CALL umPrint(umMessage,src='meandiag')
        icode=1
        cmessage='MEANDIAG: MAX_SIZE too small'
        GO TO 9999
      END IF
      nrows=ipplook(lbrow)
      ncols=ipplook(lbnpt)
      buffer_length=((field_length+io_field_padding-1)/             &
      io_field_padding)*io_field_padding
      ! Section/Item codes
      IS=ipplook(item_code)/1000
      im=ipplook(item_code)-1000*IS

      ! Ensure LEN_EXTRA is initialised
      len_extra = ipplook(lbext)

      srow_out = 1
      wcol_out = 1

      ! Packing accuracy of the data :-
      ! NB: Presence of extra data disables packing for this field
      IF (packing .AND. (ipplook(lbext) <= 0)) THEN
        comp_accrcy=                                                    &
            exppxi(modl,IS,im,                                          &
            ppx_packing_acc + um_file % meta % packing_code -1,  &
            icode,cmessage)
        lpackfield=.TRUE.
      ELSE
        comp_accrcy=-99
        lpackfield=.FALSE.
      END IF

      CALL setpos(um_file % UNIT,iwa,icode)

      subm=submodel_for_sm(im_ident)
      !             Reuse decomposition type if it is unchanged. Otherwise
      !             change it to the new type.
      d1pos=stlist(st_d1pos,ie)
      orig_decomp=current_decomp_type
      new_decomp=orig_decomp

      IF ((d1_addr(d1_imodl,d1pos,subm)  ==  atmos_im) .AND.    &
        (orig_decomp  /=  decomp_standard_atmos)) THEN

        new_decomp=decomp_standard_atmos
      END IF

      IF (new_decomp  /=  orig_decomp) THEN
        icode=0
        CALL change_decomposition(new_decomp,icode)

        IF (icode  /=  0) THEN
          IF (mype  ==  0) THEN
            WRITE(umMessage,*) 'ERROR : MEAN_DIAG'
            CALL umPrint(umMessage,src='meandiag')
            WRITE(umMessage,*) 'Failed to change decomposition to ',    &
                                 new_decomp
            CALL umPrint(umMessage,src='meandiag')
            WRITE(umMessage,*) 'Field M,S,I ',                          &
                  d1_addr(d1_imodl,d1pos,subm),                         &
                  d1_addr(d1_section,d1pos,subm),                       &
                  d1_addr(d1_item,d1pos,subm)
            CALL umPrint(umMessage,src='meandiag')
          END IF
          cmessage='MEANDIAG : Failed to change decomposition'
          GO TO 9999
        END IF

      END IF
      !             Gather full field to PE0
      ! DEPENDS ON: general_gather_field
      CALL general_gather_field(d1(field_address),buf,local_len,        &
            field_length,1,d1_addr(1,stlist(st_d1pos,ie),subm),0,       &
            -1,icode,cmessage)
      IF (icode  ==  1) THEN
        WRITE(umMessage,*)'MEANDIAG: Field number ',IS,                 &
                  'with dimensions ', ncols,' x ',                      &
                  nrows,' and gridtype ',                               &
                  d1_addr(d1_grid_type,stlist(st_d1pos,ie),subm),       &
                  'was unrecognized and not gathered.'
        CALL umPrint(umMessage,src='meandiag')
        cmessage='MEANDIAG: Unrecognized field on write'
        GO TO 9999
      ELSE IF (icode  /=  0) THEN
        GO TO 9999
      END IF
      icode=0
      IF (mype  ==  0) THEN
        ! DEPENDS ON: pp_file
        CALL pp_file(buf,-1,buffer_length,num_words,rmdi,              &
                     comp_accrcy,field_length,um_file % UNIT,          &
                     iwa,ncols,nrows,                                  &
                     packing,1000*IS+im,                               &
                     packing_type,0,                                   &
                     len_extra,srow_out,wcol_out,icode,cmessage)
      END IF
      CALL gc_isum(1, nproc, info, icode)

      IF (icode >  0) THEN
        cmessage='MEANDIAG: Error in PP_FILE - see ICODE for item'
        icode=1000*IS+im
        GO TO 9999
      END IF

      ! Increment field address to point to next level if there is one.
      field_address=field_address+local_len
    
      ! Copy work header for field to next PPfile header
      icurrll=icurrll+1                           ! Next field
      DO i=1,len1_lookup
        pplook(i,icurrll)=ipplook(i)
      END DO
      ! Reset PPheader words that differ from dump LOOKUP header conventions
      pplook(lbrel,icurrll)=2                     ! PP release no
      pplook(data_type,icurrll)=1                 ! Real field
      IF (packing_type == PC_WGDOS_Packing) THEN
        ! WGDOS packed
        pplook(lbpack,icurrll)= PC_Cray_Format * 1000 + PC_WGDOS_Packing
      ELSE IF (packing_type == PC_RunLength_Packing) THEN
        ! Run length encoded
        pplook(lbpack,icurrll)= PC_Cray_Format * 1000 + PC_RunLength_Packing
      ELSE
        ! Unpacked
        pplook(lbpack,icurrll)= PC_Cray_Format * 1000 + PC_No_Packing
      END IF
      rppval = comp_accrcy                        ! Accuracy
      pplook(bacc,icurrll) = TRANSFER(rppval,ippval)
      rppval=rmdi                                 ! Missing data
      pplook(bmdi,icurrll) = TRANSFER(rppval,ippval)
      rppval = 1.0                                ! MKS scale fac
      pplook(bmks,icurrll) = TRANSFER(rppval,ippval)

      pplook(lblrec,icurrll)=num_words         ! Packed length
      pplook(lbnrec,icurrll)=((num_words+io_field_padding-1)/     &
      io_field_padding)*io_field_padding
                                                   ! Rounded length
      pplook(lbegin,icurrll)=iwa                 ! Address
      pplook(naddr,icurrll)=iwa                  ! Address
      iwa=iwa+pplook(lbnrec,icurrll)             ! Next address

    END DO  ! End of loop over levels
  END IF
  !
END DO      ! End of loop over STASHlist entries
! Update position of last field
um_file % pp_meta % last_written_field = icurrll
! ----------------------------------------------------------------------
!  4.  Finally loop over PP headers and set correct timestamps for the
!      mean period concerned, and also reset LBTIM and LBPROC codes to
!      reflect the mean period for the individual fields.
!      NB: This loop deals with fields from both sections 2 and 3 above.
!
!  4.1 Calculate start time of meaning period from current time
!
! DEPENDS ON: time2sec
CALL time2sec(i_year,i_month,i_day,i_hour,i_minute,i_second,      &
              basis_time_days,basis_time_secs,                    &
              start_day,start_second,lcal360)
!
i=1
IF (i_ao == 1 .OR. i_ao == 2) THEN
  DO indexm=1,meanlev
    i=i*meanfreqim(indexm,i_ao)
  END DO
  ! DEPENDS ON: stp2time
  CALL stp2time(i*dumpfreqim(i_ao),                               &
        steps_per_periodim(i_ao),secs_per_periodim(i_ao),         &
                period_days,period_secs)
ELSE
  icode=312
  cmessage='MEANDIAG : I_AO has invalid value'
  GO TO 9999
END IF
start_second=start_second - period_secs
start_day   =start_day    - period_days
!
! Note: START_TIME(6) is set to Day Number, not seconds
! DEPENDS ON: sec2time
CALL sec2time(start_day,start_second,                             &
              basis_time_days,basis_time_secs,                    &
              start_time(1),start_time(2),start_time(3),          &
              start_time(4),start_time(5),start_time(7),          &
              start_time(6),lcal360)
!
!  4.2 Set start and end times in mean PP headers from START_TIME
!      and current time from model_time_mod.
!      Recalculate LBTIM and LBPROC if necessary.
!
DO indexm = 1, um_file % pp_meta % last_written_field
  !     Update YR, MON, DAT, DAY to start and end of mean period
  pplook(lbyr ,indexm)=start_time(lbyr)
  pplook(lbmon ,indexm)=start_time(lbmon)
  pplook(lbdat ,indexm)=start_time(lbdat)
  pplook(lbyrd ,indexm)=i_year
  pplook(lbmond,indexm)=i_month
  pplook(lbdatd,indexm)=i_day
  !     Decode LBTIM IA and IB elements
  lbtim_ia=pplook(lbtim,indexm)/100                ! Sample period
  lbtim_ib=(pplook(lbtim,indexm)-(lbtim_ia*100))/10 ! Time type
  !     Update HR and MIN to the start and end of the mean period
  !     unless IA and IB indicate a mean sampled at a particular time
  !     of day (assumed to represent part of a mean diurnal cycle, say),
  !     in which case the original starting offset time is
  !     retained for both the starting and ending time of day.
  !     Note: This special case is required to generate the distinguishable
  !     PP headers in the case of mean diurnal-cycle type diagnostics.
  !     It is not an ideal general solution, and may need reassessment
  !     at some time in the future.
  IF ((lbtim_ia == 24) .AND. (lbtim_ib == 2)) THEN
    pplook(lbhrd ,indexm)=pplook(lbhr ,indexm)
    pplook(lbmind ,indexm)=pplook(lbmin ,indexm)
    pplook(lbsecd ,indexm)=pplook(lbsec ,indexm)
  ELSE
    pplook(lbhr ,indexm)=start_time(lbhr)
    pplook(lbmin ,indexm)=start_time(lbmin)
    pplook(lbsec ,indexm)=start_time(lbsec)
    pplook(lbhrd ,indexm)=i_hour
    pplook(lbmind,indexm)=i_minute
    pplook(lbsecd,indexm)=i_second
  END IF
  IF (lclimrealyr) THEN      ! real-period means always start
    pplook(lbdat,indexm)=1   ! on 1st of month
    IF (pplook(lbmon,indexm)  ==  1 .AND.                         &
        pplook(lbmond,indexm)  ==  3) THEN
      pplook(lbmon,indexm)=2 ! correct start month for Feb mean
    END IF
  END IF
  !
  IF (lbtim_ia == 0) THEN                     ! Reset to dump
    lbtim_ia = (dumpfreqim(i_ao)*secs_per_periodim(i_ao))/        &
               (steps_per_periodim(i_ao)*3600)
  END IF
  IF (i_ao == 1) THEN
    !         Calendar + 20 + 100*sample_prd
    pplook(lbtim,indexm)=a_fixhd(8)+20+100*lbtim_ia
  END IF
  !
  IF (MOD(pplook(lbproc,indexm)/128,2) == 0) THEN
    pplook(lbproc,indexm)=pplook(lbproc,indexm)+128  ! not a mean
  END IF
END DO
! --------------------------------------------------------------------
!  4.2A Section to output fields in grib code (retired)
! --------------------------------------------------------------------
!
!  4.3 Buffer LOOKUP headers from work array back to file and close it
!      (note file unit will be released at the end of um_shell, since it
!       will remain reserved for re-use if subsequent means are required)
!

CALL setpos(um_file % UNIT,word_address,icode)

CALL buffout(um_file % UNIT,pplook(:,:),len1_lookup*pp_len_mean,len_io,  &
                                                          a_io)
IF (a_io /= -1.0 .OR. len_io /= len1_lookup*pp_len_mean) THEN
  ! DEPENDS ON: ioerror
  CALL ioerror('Buffer out of LOOKUP table   ',a_io,len_io,       &
                len1_lookup*pp_len_mean)
  cmessage='MEANDIAG : Error writing PPfile LOOKUP table'
  icode=314
  GO TO 9999
END IF

CALL Model_file_close(um_file % UNIT, um_file % filename, &
                      delete=ioNoDelete, error=icode)
! ----------------------------------------------------------------------
!  5. Construct mean PPfile processing requests and output to server
!     This deals with both "normal" and section 21-24 etc period means
!
IF (l_postp) THEN
  indexm = meanlev
  IF (i_ao == 1) THEN
    IF (ppselectim(indexm,i_ao) == 1) THEN
      ! Send post-processing indicator to working directory
      archfile = TRIM(um_file % filename(                       &
                      INDEX(um_file % filename,'/',.TRUE.)+1:)  &
                      )//'.arch'
      CALL assign_file_unit(archfile, arch_unit, handler="fortran")
      OPEN(UNIT=arch_unit, FILE=archfile)
      CLOSE(UNIT=arch_unit)
      CALL release_file_unit(arch_unit, handler="fortran")
    END IF
  END IF
END IF


9999 CONTINUE
IF (mype /= current_io_pe) THEN
  DEALLOCATE(pplook)
END IF
NULLIFY(pplook)
IF (lhook) CALL dr_hook(RoutineName,zhook_out,zhook_handle)
RETURN
END SUBROUTINE meandiag
